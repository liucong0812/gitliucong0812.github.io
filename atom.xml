<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>我是一颗葱</title>
  <subtitle>我说风雨中这点痛算什么！！！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-04-17T16:45:21.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Chris Liu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS开发代码规范</title>
    <link href="http://yoursite.com/2016/04/18/iOS%E5%BC%80%E5%8F%91%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    <id>http://yoursite.com/2016/04/18/iOS开发代码规范/</id>
    <published>2016-04-17T16:00:50.000Z</published>
    <updated>2016-04-17T16:45:21.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;iOS开发规范（self）&quot;&gt;&lt;a href=&quot;#iOS开发规范（self）&quot; class=&quot;headerlink&quot; title=&quot;iOS开发规范（self）&quot;&gt;&lt;/a&gt;iOS开发规范（self）&lt;/h1&gt;&lt;p&gt;Objective-C是一门面向对象的动态编程语言，主要用于编写iOS和Mac应用程序。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;strong&gt;阅读全文&amp;gt;&amp;gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;基本开发规范&quot;&gt;&lt;a href=&quot;#基本开发规范&quot; class=&quot;headerlink&quot; title=&quot;基本开发规范&quot;&gt;&lt;/a&gt;基本开发规范&lt;/h2&gt;&lt;h3 id=&quot;工程架构&quot;&gt;&lt;a href=&quot;#工程架构&quot; class=&quot;headerlink&quot; title=&quot;工程架构&quot;&gt;&lt;/a&gt;工程架构&lt;/h3&gt;&lt;p&gt;架构的几个原则，根据优先次序高低排列：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;逻辑拆分越细越好&lt;/li&gt;
&lt;li&gt;依赖关细越少越好 &lt;/li&gt;
&lt;li&gt;交互越少越好 … （交互是指项目中页面逻辑跳转并非交互设计）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一款APP主要实现的功能&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;调用网络API&lt;br&gt;如何让业务开发工程师方便安全地调用网络API？然后尽可能保证用户在各种网络环境下都能有良好的体验？&lt;/li&gt;
&lt;li&gt;界面展示&lt;br&gt;页面如何组织，才能尽可能降低业务方代码的耦合度？尽可能降低业务方开发界面的复杂度，提高他们的效率？&lt;/li&gt;
&lt;li&gt;数据的本地持久化&lt;br&gt;当数据有在本地存取的需求的时候，如何能够保证数据在本地的合理安排？如何尽可能地减小性能消耗？&lt;/li&gt;
&lt;li&gt;动态部署方案&lt;br&gt;iOS应用有审核周期，如何能够通过不发版本的方式展示新的内容给用户？如何修复紧急bug？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&quot;http://gracelancy.com/blog/2016/01/06/ape-ios-arch-design/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;猿题库iOS客户端架构设计&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.infoq.com/cn/articles/ios-app-arch-2-2&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MAC、MVVM&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.cocoachina.com/ios/20160108/14916.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;解密 MVC，MVP，MVVM以及VIPER架构&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;工程目录&quot;&gt;&lt;a href=&quot;#工程目录&quot; class=&quot;headerlink&quot; title=&quot;工程目录&quot;&gt;&lt;/a&gt;工程目录&lt;/h3&gt;&lt;p&gt;工程中的目录结构是否清晰，有条理，是衡量一个工程师很重要的因素，它是对一个项目第一直观的东西。 我查阅了很多资料，看到的内容都是各有，所以说工程目录并没有一个完全统一的一个标准。&lt;br&gt;目前，我觉得比较常规的两种结构&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;主目录按照业务分类，内目录按照模块分类(主目录按照MVC架构分类，内部根据项目模块分类)&lt;br&gt; &lt;code&gt;优点：相对比较快定位对应的业务。&lt;/code&gt;&lt;br&gt; &lt;code&gt;缺点：模块相关类太过分散，需要来回切换寻找文件，不方便开发。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://upload-images.jianshu.io/upload_images/295346-94f1461a7ee68d10.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Alt text&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;主目录按照模块分类，内目录按照业务分类&lt;br&gt; &lt;code&gt;优点：对模块的类集中化，方便管理与开发。&lt;/code&gt;&lt;br&gt; &lt;code&gt;缺点：当几个模块共用一些类时，不太好归类。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://upload-images.jianshu.io/upload_images/295346-810d6b1cfcb46994.png?imageMogr2/auto-orient/strip%7CimageView2/2&quot; alt=&quot;Alt text&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;但是信息查看后还是会发现，其实虽然说是相中结构，但是还是有一些相同点的，下面让我们来分析一下这些相同点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;公用类 （首先你会发现很多的功能类，无论你是按照业务分类，还是按照模块分类都是需要用到的，我们可以把这些归纳为公用类    &lt;/li&gt;
&lt;li&gt;网络功能类  NetworkFunction&lt;/li&gt;
&lt;li&gt;本地缓存  DataBase – 例如SQLite ，Coredata     &lt;/li&gt;
&lt;li&gt;常量 Constant – 项目用到的所有公共常量，如enum枚举类型的、Notification的Tag，常用的颜色、字符串。&lt;/li&gt;
&lt;li&gt;宏 Macros – 宏定义目录&lt;/li&gt;
&lt;li&gt;对系统类的扩展 Category – 如NSString+XXXExtension这种，就统一放在Category目录下&lt;/li&gt;
&lt;li&gt;工具类 Util/Helper –  放常用的工具类的地方&lt;/li&gt;
&lt;li&gt;三方库 Vender        &lt;/li&gt;
&lt;li&gt;资源类  Resource – 存放资源文件，图片、字体和配置文件等    &lt;ul&gt;
&lt;li&gt;Images&lt;/li&gt;
&lt;li&gt;Sounds    &lt;/li&gt;
&lt;li&gt;Videos&lt;/li&gt;
&lt;li&gt;Plists&lt;/li&gt;
&lt;li&gt;Fonts&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;http://www.samirchen.com/ios-project-structure/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;工程目录参考&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://blog.csdn.net/fanjunxi1990/article/details/9352917&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;folder 和 group的区别&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;代码组织&quot;&gt;&lt;a href=&quot;#代码组织&quot; class=&quot;headerlink&quot; title=&quot;代码组织&quot;&gt;&lt;/a&gt;代码组织&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;函数长度（行数）不应超过2/3屏幕，禁止超过70行。 : 例外：对于顺序执行的初始化函数，如果其中的过程没有提取为独立方法的必要，则不必限制长度。&lt;/li&gt;
&lt;li&gt;单个文件方法数不应超过30个&lt;/li&gt;
&lt;li&gt;不要按类别排序（如把IBAction放在一块），应按任务把相关的组合在一起&lt;/li&gt;
&lt;li&gt;禁止出现超过两层循环的代码，用函数或block替代。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;// 为了简化示例，没有错误处理，并使用了伪代码&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// 糟糕的例子&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (Task *)creatTaskWithPath:(NSString *)path &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Task *aTask;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if ([path isURL]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if ([fileManager isWritableFileAtPath:path]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if (![taskManager hasTaskWithPath:path]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                aTask = [[Task alloc] initWithPath:path];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            else &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                return nil;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        else &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            return nil;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    else &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return nil;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return aTask;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// 改写的例子&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (Task *)creatTaskWithPath:(NSString *)path &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (![path isURL]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return nil;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (![fileManager isWritableFileAtPath:path]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return nil;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if ([taskManager hasTaskWithPath:path]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return nil;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Task *aTask = [[Task alloc] initWithPath:path];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return aTask;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;h文件命名&quot;&gt;&lt;a href=&quot;#h文件命名&quot; class=&quot;headerlink&quot; title=&quot;.h文件命名&quot;&gt;&lt;/a&gt;.h文件命名&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;.h头文件描述，描述参考注释模块&lt;/li&gt;
&lt;li&gt;引用的头文件&lt;/li&gt;
&lt;li&gt;常量定义和宏定义，如常用的通知、常量和公用宏的定义 &lt;/li&gt;
&lt;li&gt;类和协议说明，使用@class和@protocol来说明某个类型为类或协议&lt;/li&gt;
&lt;li&gt;类定义，即定义@interface和其成员变量&lt;/li&gt;
&lt;li&gt;类属性，在@interface外定义类的属性&lt;/li&gt;
&lt;li&gt;类方法和实例方法&lt;/li&gt;
&lt;li&gt;协议定义&lt;/li&gt;
&lt;li&gt;扩展类别&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;m文件命名&quot;&gt;&lt;a href=&quot;#m文件命名&quot; class=&quot;headerlink&quot; title=&quot;.m文件命名&quot;&gt;&lt;/a&gt;.m文件命名&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;.m实现文件描述，描述参考注释模块&lt;/li&gt;
&lt;li&gt;引用的头文件&lt;/li&gt;
&lt;li&gt;常量定义的实现&lt;/li&gt;
&lt;li&gt;内存管理，目前采用ARC编码，这里的内存指在dealloc文件中移除通知，清空特殊数据等，此步可选。&lt;/li&gt;
&lt;li&gt;数据初始化和界面初始化&lt;/li&gt;
&lt;li&gt;详情实现方法，使用#parma mark 的 Detail methods来分组&lt;/li&gt;
&lt;li&gt;其他归类方法的分组&lt;/li&gt;
&lt;li&gt;自定义类的协议实现方法，按照不同的协议分组显示&lt;/li&gt;
&lt;li&gt;系统类的协议实现方法，按照不同的协议分组显示&lt;/li&gt;
&lt;li&gt;扩展类别的实现方法&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;头文件引用&quot;&gt;&lt;a href=&quot;#头文件引用&quot; class=&quot;headerlink&quot; title=&quot;头文件引用&quot;&gt;&lt;/a&gt;头文件引用&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;#class&lt;/code&gt;&lt;br&gt;   主要是用于声明一个类，告诉编译器它后面的名字是一个类的名字，而这个类的定义实现是暂时不用知道的，后面会告诉你.也是因为在@class仅仅只是声明一个类，所以在后面的实现文件里面是需要去#import这个类，这时候才包含了这个被引用的类的所有信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;#import&lt;/code&gt;&lt;br&gt;  当引用的是一个Objective-C或者Objective-C++的头文件时，使用&lt;code&gt;#import&lt;/code&gt; &lt;code&gt;#import&lt;/code&gt; 大部分功能和#include是一样的，但是他处理了重复引用的问题，我们在引用文件的时候不用再去自己进行重复引用处理.&lt;code&gt;#import&lt;/code&gt; 确定一个文件只能被导入一次，这使你在递归包含中不会出现问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;#include&lt;/code&gt;&lt;br&gt;  当引用的是一个C或者C++的头文件时，使用&lt;code&gt;#include&lt;/code&gt;，这时必须要保证被引用的文件提供了保护域（#define guard）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;#include&lt;/code&gt;与&lt;code&gt;#import&lt;/code&gt;在引用一个类的时候会包含这个类的所有信息包括变量方法等，但是这样做会对编译效率造成影响.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;比如有100个类都#import了ClassA，那么在编译的时候这100个类都会去对ClassA处理.又比如A被B引用，B被C引用，C被D引用…..此时如果A被修改，那么后面的B，C，D…..都需要重新进行编译.&lt;/li&gt;
&lt;li&gt;还有一个用法会引起编译错误的就是在ClassA中#import ClassB 在ClassB中#import ClassA那么在编译的时候也会出现未知错误。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以一般来说，在interface中引用一个类，就用@class，它会把这个类作为一个类型来使用，而在实现这个interface的文件中，如果需要引用这个类的实体变量或者方法之类的，还是需要import这个在@class中声明的类。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;引用框架的根头文件 &lt;/p&gt;
&lt;p&gt;  每一个框架都会有一个和框架同名的头文件，它包含了框架内接口的所有引用，在使用框架的时候，应该直接引用这个根头文件，而不是其它子模块的头文件，即使是你只用到了其中的一小部分，编译器会自动完成优化的。&lt;/p&gt;
  &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//正确，引用根头文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;lt;Foundation/Foundation.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//错误，不要单独引用框架内的其它头文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;lt;Foundation/NSArray.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;lt;Foundation/NSString.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&amp;lt;&amp;gt; 多指用来引用系统的头文件，或者库的头文件&lt;/li&gt;
&lt;li&gt;&lt;p&gt;“” 引用自定义的头文件&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/chengwuli125/article/details/9705315&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;区别 #import #include&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;命名规范&quot;&gt;&lt;a href=&quot;#命名规范&quot; class=&quot;headerlink&quot; title=&quot;命名规范&quot;&gt;&lt;/a&gt;命名规范&lt;/h2&gt;&lt;h3 id=&quot;基本规范&quot;&gt;&lt;a href=&quot;#基本规范&quot; class=&quot;headerlink&quot; title=&quot;基本规范&quot;&gt;&lt;/a&gt;基本规范&lt;/h3&gt;&lt;h4 id=&quot;可读性高&quot;&gt;&lt;a href=&quot;#可读性高&quot; class=&quot;headerlink&quot; title=&quot;可读性高&quot;&gt;&lt;/a&gt;可读性高&lt;/h4&gt;&lt;h5 id=&quot;清晰，简洁&quot;&gt;&lt;a href=&quot;#清晰，简洁&quot; class=&quot;headerlink&quot; title=&quot;清晰，简洁&quot;&gt;&lt;/a&gt;清晰，简洁&lt;/h5&gt;&lt;p&gt; 仿照 Cocoa 风格来，使用长命名风格，通常不应该使用缩写名称（除非苹果官方设定的一些名称简写）&lt;/p&gt;
&lt;h5 id=&quot;驼峰命名的掌握&quot;&gt;&lt;a href=&quot;#驼峰命名的掌握&quot; class=&quot;headerlink&quot; title=&quot;驼峰命名的掌握&quot;&gt;&lt;/a&gt;驼峰命名的掌握&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;大驼峰命名法(UpperCamelCase) 开头字母为大写，其他单词首字母大写(类名) &lt;/li&gt;
&lt;li&gt;小驼峰命名法(lowerCamelCase) 开头字母为小写，其他单词首字母大写（类成员、方法）&lt;/li&gt;
&lt;li&gt;局部变量大小写首选小驼峰，也可以使用小写下划线的形式(snake_case)&lt;/li&gt;
&lt;li&gt;C函数的命名用大驼峰&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;防止命名冲突&quot;&gt;&lt;a href=&quot;#防止命名冲突&quot; class=&quot;headerlink&quot; title=&quot;防止命名冲突&quot;&gt;&lt;/a&gt;防止命名冲突&lt;/h4&gt;&lt;h5 id=&quot;避免混淆&quot;&gt;&lt;a href=&quot;#避免混淆&quot; class=&quot;headerlink&quot; title=&quot;避免混淆&quot;&gt;&lt;/a&gt;避免混淆&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;不要使用下划线作为前缀&lt;/p&gt;
&lt;p&gt;  避免使用下划线作为前缀，有意思私人的方法名（使用下划线字符作为一个实例变量名称的前缀是允许的） 。苹果公司保留使用这种约定。由第三方使用可能会导致命名空间冲突;他们可能会无意中覆盖现有的私有方法有一个属于自己的类，这会具有灾难性的后果。查看约定私有方法的建议，遵循私有API 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;不要使用大写字母作为方法开发（除了众所周知的缩写外，如PDF，MD5，）&lt;/p&gt;
&lt;p&gt;  如果方法名以一个众所周知的大写缩略词开始，该规则不适用&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;避免使用的词汇&quot;&gt;&lt;a href=&quot;#避免使用的词汇&quot; class=&quot;headerlink&quot; title=&quot;避免使用的词汇&quot;&gt;&lt;/a&gt;避免使用的词汇&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;init&lt;/li&gt;
&lt;li&gt;set&lt;/li&gt;
&lt;li&gt;get&lt;/li&gt;
&lt;li&gt;do&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;前缀&quot;&gt;&lt;a href=&quot;#前缀&quot; class=&quot;headerlink&quot; title=&quot;前缀&quot;&gt;&lt;/a&gt;前缀&lt;/h5&gt;&lt;p&gt;它由二到三个大写字母组成，不使用下划线和子前缀。Apple 宣传其保留使用所有“两个字母前缀”(tow-letter prefixed)的权利。所以你自己选用的前缀应该是三个字母的。你可以在苹果官网 &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Conventions/Conventions.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Class Names Must Be Unique Across an Entire App&lt;/a&gt; 看到上述说明:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;命名类、协议、函数、常量和typedef结构体时使用前缀&lt;/li&gt;
&lt;li&gt;前缀可以防止第三方开发者与Apple的命名冲突&lt;/li&gt;
&lt;li&gt;同样可以防止Apple内部的命名冲突&lt;/li&gt;
&lt;li&gt;结构体字段不使用前缀&lt;/li&gt;
&lt;li&gt;方法名不使用前缀（因为它存在于特定类的命名空间中）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;类名的规范&quot;&gt;&lt;a href=&quot;#类名的规范&quot; class=&quot;headerlink&quot; title=&quot;类名的规范&quot;&gt;&lt;/a&gt;类名的规范&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;所有的类名均以大写字母开头，多单词组合时，后面的单词首字母大写，类名必须是有意义的；&lt;/li&gt;
&lt;li&gt;继承UIView时应以View结尾，例如:LoginView；&lt;/li&gt;
&lt;li&gt;继承UIViewController时应以Controller结尾；&lt;/li&gt;
&lt;li&gt;所有保存数据的实体对象以Model结尾，例如:UserModel&lt;/li&gt;
&lt;li&gt;category 避免命名重复&lt;/li&gt;
&lt;li&gt;类名冲突（多见导入第三方或者静态库，category时），所以需要在你创建的时候，前缀一定要写好，如果发生冲突，可以进行修改类名来解决冲突。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;http://pinka.cn/2014/04/ios%E9%9D%99%E6%80%81%E5%BA%93%E7%9A%84%E9%82%A3%E4%BA%9B%E5%9D%91/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;静态库的那些坑&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.devtang.com/2015/01/31/write-sdk-tips/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;写iOS SDK的注意事项&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;资源命名的规范&quot;&gt;&lt;a href=&quot;#资源命名的规范&quot; class=&quot;headerlink&quot; title=&quot;资源命名的规范&quot;&gt;&lt;/a&gt;资源命名的规范&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;资源文件常用命名规则为：模块功能类型（+_屏幕尺寸，可选）;&lt;/li&gt;
&lt;li&gt;所有资源命名单词均采用小写，中间使用”_”进行连接；&lt;/li&gt;
&lt;li&gt;共用素材前面采用common命名；&lt;/li&gt;
&lt;li&gt;资源命名切记不能使用拼音和汉字进行命名；&lt;/li&gt;
&lt;li&gt;严禁使用连续下划线进行命名，例如” variable&lt;code&gt;_&lt;/code&gt;name”和” variable&lt;code&gt;__&lt;/code&gt;name”很难区分，下划线也不能出现的资源名称前或结尾；&lt;/li&gt;
&lt;li&gt;资源均需分为单倍图和二倍图&lt;/li&gt;
&lt;li&gt;常用资源命名的类型缩写&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;方法-函数命名的规范&quot;&gt;&lt;a href=&quot;#方法-函数命名的规范&quot; class=&quot;headerlink&quot; title=&quot;方法/函数命名的规范&quot;&gt;&lt;/a&gt;方法/函数命名的规范&lt;/h3&gt;&lt;h4 id=&quot;方法&quot;&gt;&lt;a href=&quot;#方法&quot; class=&quot;headerlink&quot; title=&quot;方法&quot;&gt;&lt;/a&gt;方法&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;方法的命名应使用有意义的单词组成，且以小写字母开头，多单词组合时，后面的单词首字母大写；&lt;/li&gt;
&lt;li&gt;以get、set开头的方法有特殊的意义，不要随意定义 &lt;ul&gt;
&lt;li&gt;set是属性默认的设置方法，如果函数不是为了设置类成员，则不要用set开头，可用setup替代；&lt;/li&gt;
&lt;li&gt;get和属性放大无关，但在Cocoa中，其标准行为是通过引用传值，而不是直接返回结果的。欲获取变量，直接以变量名为名，如：userInfomation，而不是getUserInfomation。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;方法名应该尽可能读起来像一句话，参数名就相对方法名的补充说明，例如replaceCharactersInRange:withString;&lt;/li&gt;
&lt;li&gt;不要再方法名中使用类似 pointer,ptr这样的字眼去表示指针，参数本身的类型足以说明&lt;/li&gt;
&lt;li&gt;不要使用只有一两个字母的参数名.不要使用简写，拼出完整的单词&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不要使用下划线作为方法名&lt;/strong&gt; &lt;/li&gt;
&lt;li&gt;以 alloc、copy、init、mutableCopy、new 开头的方法要注意，它们会改变ARC的行为。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#!objective-c&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// OK&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (NSString *)name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 糟糕，应用上面的写法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (NSString *)getName;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// OK，但极少使用&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)getName:(NSString **)buffer range:(NSRange)inRange;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// OK&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (NSSize)cellSize;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 糟糕，应用上面的写法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (NSSize)calcCellSize;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 对 controller 做一般设置，OK&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)setupController;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 列出具体设置的内容，更好&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)setupControllerObservers;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 糟糕，set 专用于设置属性&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)setController;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果方法是为了获取对象的一个属性值，直接用属性名称来命名这个方法，注意不要添加get或者其他的动词前缀：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//正确，使用属性名来命名方法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (NSSize)cellSize;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//错误，添加了多余的动词前缀&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (NSSize)calcCellSize;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (NSSize)getCellSize;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;对于有多个参数的方法，务必在每一个参数前都添加关键词，关键词应当清晰说明参数的作用：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//正确，保证每个参数都有关键词修饰&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)sendAction:(SEL)aSelector toObject:(id)anObject forAllCells:(BOOL)flag;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//错误，遗漏关键词&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)sendAction:(SEL)aSelector :(id)anObject :(BOOL)flag;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//正确&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (id)viewWithTag:(NSInteger)aTag;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//错误，关键词的作用不清晰&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (id)taggedView:(int)aTag;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;不要用and来连接两个参数，通常and用来表示方法执行了两个相对独立的操作（从设计上来说，这时候应该拆分成两个独立的方法）：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//错误，不要使用&amp;quot;and&amp;quot;来连接参数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (int)runModalForDirectory:(NSString *)path andFile:(NSString *)name andTypes:(NSArray *)fileTypes;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//正确，使用&amp;quot;and&amp;quot;来表示两个相对独立的操作&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (BOOL)openFile:(NSString *)fullPath withApplication:(NSString *)appName andDeactivate:(BOOL)flag;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;下面列举了一些常用参数名：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;...action:(SEL)aSelector&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...alignment:(int)mode&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...atIndex:(int)index&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...content:(NSRect)aRect&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...doubleValue:(double)aDouble&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...floatValue:(float)aFloat&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...font:(NSFont *)fontObj&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...frame:(NSRect)frameRect&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...intValue:(int)anInt&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...keyEquivalent:(NSString *)charCode&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...length:(int)numBytes&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...point:(NSPoint)aPoint&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...stringValue:(NSString *)aString&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...tag:(int)anInt&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...target:(id)anObject&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...title:(NSString *)aString&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;函数（Functions）&quot;&gt;&lt;a href=&quot;#函数（Functions）&quot; class=&quot;headerlink&quot; title=&quot;函数（Functions）&quot;&gt;&lt;/a&gt;函数（Functions）&lt;/h4&gt;&lt;p&gt;在很多场合仍然需要用到函数，比如说如果一个对象是一个单例，那么应该使用函数来代替类方法执行相关操作。&lt;/p&gt;
&lt;p&gt;函数的命名和方法有一些不同，主要是：&lt;/p&gt;
&lt;p&gt;函数名称一般带有缩写前缀，表示方法所在的框架。&lt;/p&gt;
&lt;p&gt;前缀后的单词以“驼峰”表示法显示，第一个单词首字母大写。&lt;/p&gt;
&lt;p&gt;函数名的第一个单词通常是一个动词，表示方法执行的操作：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSHighlightRect&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSDeallocateObject&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果函数返回其参数的某个属性，省略动词：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;unsigned int NSEventMaskFromType(NSEventType type)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;float NSHeight(NSRect aRect)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果函数通过指针参数来返回值，需要在函数名中使用Get：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;const char *NSGetSizeAndAlignment(const char *typePtr, unsigned int *sizep, unsigned int *alignp)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;函数的返回类型是BOOL时的命名：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;BOOL NSDecimalIsNotANumber(const NSDecimal *decimal)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;protocol命名规范&quot;&gt;&lt;a href=&quot;#protocol命名规范&quot; class=&quot;headerlink&quot; title=&quot;protocol命名规范&quot;&gt;&lt;/a&gt;protocol命名规范&lt;/h3&gt;&lt;p&gt;好的协议名应能立刻让人分辨出这不是一个类名，除了以常用的 delegate、dateSource 做结尾外，还可以使用 …ing 这种形式，如：NSCoding、NSCopying、NSLocking。&lt;/p&gt;
&lt;p&gt;委托方法 (或委派方法) 是指那些对象调用在其委托 (如果委托实现他们) 发生某些事件时。他们有一种独特的形式，这同样适用于调用对象的数据源中的方法: 开始通过确定发送消息的对象的类的名称:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;省略了前缀的类名和首字母小写&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (BOOL)tableView:(NSTableView *)tableView shouldSelectRow:(int)row;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (BOOL)application:(NSApplication *)sender openFile:(NSString *)filename;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;类名称省略前缀，第一个字母是小写。&lt;/p&gt;
&lt;p&gt;除非该方法仅有一个参数，发件人一个冒号被贴的类别名称 (参数对委托对象的引用)。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以发送消息的对象开始的规则不适用下列两种情况&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;只有一个sender参数的方法&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (BOOL)applicationOpenUntitledFile:(NSApplication *)sender;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;响应notification的方法（方法的唯一参数就是notification）&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)windowDidChangeScreen:(NSNotification *)notification;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;使用单词 did 和 will 来通知delegate&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;“did”will”用于调用以通知委托，&lt;/p&gt;
&lt;p&gt;did 表示某些事已发生&lt;/p&gt;
&lt;p&gt;will 表示某些事将要发生&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)browserDidScroll:(NSBrowser *)sender;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (NSUndoManager *)windowWillReturnUndoManager:(NSWindow *)window;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;虽然您可以使用”did”或”will”方法被调用时，要问要做代表另一个对象的委托，”should”是首选。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (BOOL)windowShouldClose:(id)sender;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;询问delegate是否可以执行某个行为时可以使用 did 或 will，不过 should 更完美&lt;/p&gt;
&lt;h3 id=&quot;Block命名规范&quot;&gt;&lt;a href=&quot;#Block命名规范&quot; class=&quot;headerlink&quot; title=&quot;Block命名规范&quot;&gt;&lt;/a&gt;Block命名规范&lt;/h3&gt;&lt;p&gt;根据block的长度，有不同的书写规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;较短的block可以写在一行内。&lt;/li&gt;
&lt;li&gt;如果分行显示的话，block的右括号}应该和调用block那行代码的第一个非空字符对齐。&lt;/li&gt;
&lt;li&gt;block内的代码采用4个空格的缩进。&lt;/li&gt;
&lt;li&gt;如果block过于庞大，应该单独声明成一个变量来使用。&lt;/li&gt;
&lt;li&gt;^和(之间，^和{之间都没有空格，参数列表的右括号)和{之间有一个空格。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//较短的block写在一行内&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[operation setCompletionBlock:^&amp;#123; [self onOperationDone]; &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//分行书写的block，内部使用4空格缩进&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[operation setCompletionBlock:^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self.delegate newDataAvailable];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//使用C语言API调用的block遵循同样的书写规则&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_async(_fileIOQueue, ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSString* path = [self sessionFilePath];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (path) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      // ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//较长的block关键字可以缩进后在新行书写，注意block的右括号&amp;apos;&amp;#125;&amp;apos;和调用block那行代码的第一个非空字符对齐&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[[SessionService sharedService]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    loadWindowWithCompletionBlock:^(SessionWindow *window) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if (window) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          [self windowDidLoad:window];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; else &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          [self errorLoadingWindow];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//较长的block参数列表同样可以缩进后在新行书写&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[[SessionService sharedService]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    loadWindowWithCompletionBlock:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ^(SessionWindow *window) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if (window) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              [self windowDidLoad:window];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125; else &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              [self errorLoadingWindow];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//庞大的block应该单独定义成变量使用&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void (^largeBlock)(void) = ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[_operationQueue addOperationWithBlock:largeBlock];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//在一个调用中使用多个block，注意到他们不是像函数那样通过&amp;apos;:&amp;apos;对齐的，而是同时进行了4个空格的缩进&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[myObject doSomethingWith:arg1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    firstBlock:^(Foo *a) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    secondBlock:^(Bar *b) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;通知命名规范&quot;&gt;&lt;a href=&quot;#通知命名规范&quot; class=&quot;headerlink&quot; title=&quot;通知命名规范&quot;&gt;&lt;/a&gt;通知命名规范&lt;/h3&gt;&lt;p&gt;Notification的格式&lt;/p&gt;
&lt;p&gt;类/头文件名+进行状态+通知名称+Notification&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[Name of associated class] + [Did | Will] + [UniquePartOfName] + Notification&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSApplicationDidBecomeActiveNotification&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSWindowDidMiniaturizeNotification&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSTextViewDidChangeSelectionNotification&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSColorPanelColorDidChangeNotificatio&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;属性和实例变量命名规范&quot;&gt;&lt;a href=&quot;#属性和实例变量命名规范&quot; class=&quot;headerlink&quot; title=&quot;属性和实例变量命名规范&quot;&gt;&lt;/a&gt;属性和实例变量命名规范&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;变量命名采用小驼峰的形式，第一个单词首字母小写，其他单词所字母大写，例如:username&lt;/li&gt;
&lt;li&gt;对于一些特殊类型的变量，命名时需要带上类型，如NSArray的变量命名为xxxArray或xxxList，其他的类型可同样命名，如xxxSize、xxxDictionary（可简写为xxxDic）等。&lt;/li&gt;
&lt;li&gt;对于常用系统的UI控件，命名时要后缀以特定的控件名，例如:&lt;/li&gt;
&lt;li&gt;循环控制变量通过可使用单一的字符，如i、j、k等，也可以使用有意义的名字，如objectIndex，建议使用后者。&lt;/li&gt;
&lt;li&gt;尽量避免使用全局变量，如果必须使用全局变量则必须加前缀”pub_”进行和普通变量的区分&lt;/li&gt;
&lt;li&gt;私有实例变量前加一个下划线，如_myPrivateVarible&lt;/li&gt;
&lt;li&gt;如果需要声明实例变量，指定关键字@private 或 @protected&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;Property&quot;&gt;&lt;a href=&quot;#Property&quot; class=&quot;headerlink&quot; title=&quot;Property&quot;&gt;&lt;/a&gt;Property&lt;/h4&gt;&lt;p&gt;如果property表示为一个名词或动词，格式如下&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;@property (…) 类型 名词/动词 ;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@property (strong) NSString *title;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (assign) BOOL showsAlpha;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如果property表示为一个形容词&lt;/p&gt;
&lt;p&gt;  可省略 ”is” 前缀&lt;/p&gt;
&lt;p&gt;  但要指定getter方法的惯用名称&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@property (assign, getter=isEditable) BOOL editable;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;实例变量&quot;&gt;&lt;a href=&quot;#实例变量&quot; class=&quot;headerlink&quot; title=&quot;实例变量&quot;&gt;&lt;/a&gt;实例变量&lt;/h4&gt;&lt;p&gt;通常不应该直接访问实例变量&lt;br&gt;init、dealloc、accessor methods等方法内部例外&lt;br&gt;实例变量以下划线 “_” 开始&lt;br&gt;确保实例变量描述了所存储的属性&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@implementation MyClass &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BOOL _showsTitle;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果想要修改property的实例变量名，使用 @synthesize语句&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@implementation MyClass&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@synthesize showsTitle=_showsTitle;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;常量命名规范&quot;&gt;&lt;a href=&quot;#常量命名规范&quot; class=&quot;headerlink&quot; title=&quot;常量命名规范&quot;&gt;&lt;/a&gt;常量命名规范&lt;/h3&gt;&lt;h4 id=&quot;枚举常量&quot;&gt;&lt;a href=&quot;#枚举常量&quot; class=&quot;headerlink&quot; title=&quot;枚举常量&quot;&gt;&lt;/a&gt;枚举常量&lt;/h4&gt;&lt;p&gt;使用枚举来关联一组integer常量&lt;/p&gt;
&lt;p&gt;枚举常量和typedef遵循函数的命名规范，下面的例子是 NSMatrix.h&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;typedef NS_ENUM(NSInteerger NSMatrixMode) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSRadioModeMatrix = 0,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSHighlightModeMatrix = 1,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSListModeMatrix = 2,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSTrackModeMatrix = 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; NSMatrixMode;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Typedef 标记 (在上述示例中的 _NSMatrixMode) 是不必要的注意。&lt;/p&gt;
&lt;p&gt;你可以为bit masks之类的东西创建一个匿名枚举&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;typedef NS_OPTIONS(NSUInteger, NSWindowMask) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSBorderlessWindowMask = 0,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSTitledWindowMask = 1 &amp;lt;&amp;lt; 0,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSClosableWindowMask = 1 &amp;lt;&amp;lt; 1,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSMiniaturizableWindowMask = 1 &amp;lt;&amp;lt; 2,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSResizableWindowMask = 1 &amp;lt;&amp;lt; 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;使用const创建的常量&quot;&gt;&lt;a href=&quot;#使用const创建的常量&quot; class=&quot;headerlink&quot; title=&quot;使用const创建的常量&quot;&gt;&lt;/a&gt;使用const创建的常量&lt;/h4&gt;&lt;p&gt;使用const关键字的常量&lt;/p&gt;
&lt;p&gt;使用const关键字来创建一个float常量&lt;/p&gt;
&lt;p&gt;你可以使用const关键字来创建一个与其他常量不相关的integer常量，否则，使用枚举&lt;/p&gt;
&lt;p&gt;使用const关键字的常量也遵循函数的命名规则&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;const float NSLightGray;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;其他类型的常量&quot;&gt;&lt;a href=&quot;#其他类型的常量&quot; class=&quot;headerlink&quot; title=&quot;其他类型的常量&quot;&gt;&lt;/a&gt;其他类型的常量&lt;/h4&gt;&lt;p&gt;通常不应使用 #define 预编译指令来创建常量&lt;/p&gt;
&lt;p&gt;integer常量，使用枚举&lt;/p&gt;
&lt;p&gt;float常量，使用 const 修饰符&lt;/p&gt;
&lt;p&gt;对 #define 预编译指令，大写所有字母&lt;/p&gt;
&lt;p&gt;比如 DEBUG 判断&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#ifdef DEBUG&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;注意的时，cocoa官网宏 字首和字尾都有双下划线&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;__MACH__&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;定义NSString常量来作为Notification和Key值&lt;/p&gt;
&lt;p&gt;这样做可以有效防止拼写错误&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;APPKIT_EXTERN NSString *NSPrintCopies;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;代码规范&quot;&gt;&lt;a href=&quot;#代码规范&quot; class=&quot;headerlink&quot; title=&quot;代码规范&quot;&gt;&lt;/a&gt;代码规范&lt;/h2&gt;&lt;h3 id=&quot;基本规范-1&quot;&gt;&lt;a href=&quot;#基本规范-1&quot; class=&quot;headerlink&quot; title=&quot;基本规范&quot;&gt;&lt;/a&gt;基本规范&lt;/h3&gt;&lt;h4 id=&quot;代码缩进&quot;&gt;&lt;a href=&quot;#代码缩进&quot; class=&quot;headerlink&quot; title=&quot;代码缩进&quot;&gt;&lt;/a&gt;代码缩进&lt;/h4&gt;&lt;p&gt;不要在工程里使用Tab键，使用空格来进行缩进。在Xcode &amp;gt; Preferences &amp;gt; Text Editing将Tab和自动缩进都设置为4个空格。（Google的标准是使用两个空格来缩进，但这里还是推荐使用Xcode默认的设置。）&lt;/p&gt;
&lt;h4 id=&quot;每一行最大的长度&quot;&gt;&lt;a href=&quot;#每一行最大的长度&quot; class=&quot;headerlink&quot; title=&quot;每一行最大的长度&quot;&gt;&lt;/a&gt;每一行最大的长度&lt;/h4&gt;&lt;p&gt;同样的，在Xcode &amp;gt; Preferences &amp;gt; Text Editing &amp;gt; Page guide at column:中将最大行长设置为80，过长的一行代码将会导致可读性问题。&lt;/p&gt;
&lt;h4 id=&quot;空格，换行原则&quot;&gt;&lt;a href=&quot;#空格，换行原则&quot; class=&quot;headerlink&quot; title=&quot;空格，换行原则&quot;&gt;&lt;/a&gt;空格，换行原则&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;使用Tabs键，不使用空格，一个Tabs设置为四个空格&lt;strong&gt;（设置完毕之后）&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;空行起着分隔程序段落的作用。适当的空行可以使程序的布局更加清晰。&lt;/li&gt;
&lt;li&gt;关键字与其后的表达式之间要有空格&lt;/li&gt;
&lt;li&gt;单目操作符不应与它们的操作数分开（如’!’和’^’等）。&lt;/li&gt;
&lt;li&gt;除’ , ’外，其它双目操作符应与它们的操作数用空格隔开。&lt;/li&gt;
&lt;li&gt;.h中协议&amp;lt;&amp;gt;前面有一个空格。&lt;/li&gt;
&lt;li&gt;.h中成员声明时，类型与变量之间有至少1个空格。*号靠近变量，不靠近类型。&lt;/li&gt;
&lt;li&gt;@property后留1个空格，（）里面，逗号紧跟前一变量，与后一变量之间留1&lt;br&gt;个空格。（）外面，先留1个空格，再声明属性。&lt;/li&gt;
&lt;li&gt;类方法声明在方法类型与返回类型之间要有空格。&lt;/li&gt;
&lt;li&gt;返回类型与之间留1个空格，方法参数中返回类型与之间留1个空格&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;语法糖（高）&quot;&gt;&lt;a href=&quot;#语法糖（高）&quot; class=&quot;headerlink&quot; title=&quot;语法糖（高）&quot;&gt;&lt;/a&gt;语法糖（高）&lt;/h4&gt;&lt;p&gt;应该使用可读性更好的语法糖来构造&lt;code&gt;NSArray&lt;/code&gt;，&lt;code&gt;NSDictionary&lt;/code&gt;等数据结构，避免使用冗长的&lt;code&gt;alloc&lt;/code&gt;,&lt;code&gt;init&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;如果构造代码写在一行，需要在括号两端留有一个空格，使得被构造的元素于与构造语法区分开来：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//正确，在语法糖的&amp;quot;[]&amp;quot;或者&amp;quot;{}&amp;quot;两端留有空格
NSArray *array = @[ [foo description], @&amp;quot;Another String&amp;quot;, [bar description] ];
NSDictionary *dict = @{ NSForegroundColorAttributeName : [NSColor redColor] };

//不正确，不留有空格降低了可读性
NSArray* array = @[[foo description], [bar description]];
NSDictionary* dict = @{NSForegroundColorAttributeName: [NSColor redColor]};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果构造代码不写在一行内，构造元素需要使用&lt;strong&gt;两个空格&lt;/strong&gt;来进行缩进，右括号&lt;code&gt;]&lt;/code&gt;或者&lt;code&gt;}&lt;/code&gt;写在新的一行，并且与调用语法糖那行代码的第一个非空字符对齐：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;NSArray *array = @[
 @&amp;quot;This&amp;quot;,
 @&amp;quot;is&amp;quot;,
 @&amp;quot;an&amp;quot;,
 @&amp;quot;array&amp;quot;
];

NSDictionary *dictionary = @{
 NSFontAttributeName : [NSFont fontWithName:@&amp;quot;Helvetica-Bold&amp;quot; size:12],
 NSForegroundColorAttributeName : fontColor
};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;构造字典时，字典的Key和Value与中间的冒号&lt;code&gt;:&lt;/code&gt;都要留有一个空格，多行书写时，也可以将Value对齐：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//正确，冒号&amp;apos;:&amp;apos;前后留有一个空格
NSDictionary *option1 = @{
 NSFontAttributeName : [NSFont fontWithName:@&amp;quot;Helvetica-Bold&amp;quot; size:12],
 NSForegroundColorAttributeName : fontColor
};

//正确，按照Value来对齐
NSDictionary *option2 = @{
 NSFontAttributeName :            [NSFont fontWithName:@&amp;quot;Arial&amp;quot; size:12],
 NSForegroundColorAttributeName : fontColor
};

//错误，冒号前应该有一个空格
NSDictionary *wrong = @{
 AKey:       @&amp;quot;b&amp;quot;,
 BLongerKey: @&amp;quot;c&amp;quot;,
};

//错误，每一个元素要么单独成为一行，要么全部写在一行内
NSDictionary *alsoWrong= @{ AKey : @&amp;quot;a&amp;quot;,
                        BLongerKey : @&amp;quot;b&amp;quot; };

//错误，在冒号前只能有一个空格，冒号后才可以考虑按照Value对齐
NSDictionary *stillWrong = @{
 AKey       : @&amp;quot;b&amp;quot;,
 BLongerKey : @&amp;quot;c&amp;quot;,
};
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;花括号的使用&quot;&gt;&lt;a href=&quot;#花括号的使用&quot; class=&quot;headerlink&quot; title=&quot;花括号的使用&quot;&gt;&lt;/a&gt;花括号的使用&lt;/h4&gt;&lt;h5 id=&quot;判断语句中&quot;&gt;&lt;a href=&quot;#判断语句中&quot; class=&quot;headerlink&quot; title=&quot;判断语句中&quot;&gt;&lt;/a&gt;判断语句中&lt;/h5&gt;&lt;p&gt;方法大括号和其他大括号(if/else/switch/while 等.)总是在同一行语句打开但在新行中关闭。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;应该&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if (user.isHappy) &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //Do something  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; else &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //Do something else  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;不应该：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if (user.isHappy)  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  //Do something  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;else &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  //Do something else  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h5 id=&quot;方法中&quot;&gt;&lt;a href=&quot;#方法中&quot; class=&quot;headerlink&quot; title=&quot;方法中&quot;&gt;&lt;/a&gt;方法中&lt;/h5&gt;&lt;p&gt;一个典型的Objective-C函数应该是这样的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (void)writeVideoFrameWithData:(NSData *)frameData timeStamp:(int)timeStamp {
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在&lt;code&gt;-&lt;/code&gt;和&lt;code&gt;(void)&lt;/code&gt;之间应该有一个空格，第一个大括号&lt;code&gt;{&lt;/code&gt;的位置在函数所在行的末尾，同样应该有一个空格。&lt;/p&gt;
&lt;p&gt;如果一个函数有特别多的参数或者名称很长，应该将其按照&lt;code&gt;:&lt;/code&gt;来对齐分行显示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-(id)initWithModel:(IPCModle)mod
   ConnectType:(IPCConnectType)connectType
    Resolution:(IPCResolution)resolution
      AuthName:(NSString *)authName
      Password:(NSString *)password
           MAC:(NSString *)mac
          AzIp:(NSString *)az_ip
         AzDns:(NSString *)az_dns
         Token:(NSString *)token
         Email:(NSString *)email
      Delegate:(id&amp;lt;IPCConnectHandlerDelegate&amp;gt;)delegate;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在分行时，如果第一段名称过短，后续名称可以以Tab的长度（4个空格）为单位进行缩进&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)short:(GTMFoo *)theFoo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   	  longKeyword:(NSRect)theRect&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;evenLongerKeyword:(float)theInterval&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       	    error:(NSError **)theError &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h5 id=&quot;代码块中&quot;&gt;&lt;a href=&quot;#代码块中&quot; class=&quot;headerlink&quot; title=&quot;代码块中&quot;&gt;&lt;/a&gt;代码块中&lt;/h5&gt;&lt;p&gt;应该避免以冒号对齐的方式来调用方法。因为有时方法签名可能有3个以上的冒号和冒号对齐会使代码更加易读。请不要这样做，尽管冒号对齐的方法包含代码块，因为Xcode的对齐方式令它难以辨认。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;应该&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// blocks are easily readable  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[UIView animateWithDuration:1.0 animations:^&amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  // something  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; completion:^(BOOL finished) &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  // something  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;不应该&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// colon-aligning makes the block indentation hard to read  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[UIView animateWithDuration:1.0  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 animations:^&amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                     // something  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 &amp;#125;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 completion:^(BOOL finished) &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                     // something  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;方法调用&quot;&gt;&lt;a href=&quot;#方法调用&quot; class=&quot;headerlink&quot; title=&quot;方法调用&quot;&gt;&lt;/a&gt;方法调用&lt;/h3&gt;&lt;p&gt;方法调用的格式和书写差不多，可以按照函数的长短来选择写在一行或者分成多行：&lt;/p&gt;
&lt;p&gt;写在一行&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[myObject doFooWith:arg1 name:arg2 error:arg3];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;分行写，按照’:’对齐&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[myObject doFooWith:arg1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	       	   name:arg2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	       	  error:arg3];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;```	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;第一段名称过短的话后续可以进行缩进&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;[myObj short:arg1&lt;br&gt;      longKeyword:arg2&lt;br&gt;evenLongerKeyword:arg3&lt;br&gt;            error:arg4];&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;以下写法是错误的：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;错误，要么写在一行，要么全部分行&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;[myObject doFooWith:arg1 name:arg2&lt;br&gt;                          error:arg3];&lt;br&gt;[myObject doFooWith:arg1&lt;br&gt;               name:arg2 error:arg3];&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;错误，按照&amp;apos;:&amp;apos;来对齐，而不是关键字&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;[myObject doFooWith:arg1&lt;br&gt;          name:arg2&lt;br&gt;              error:arg3];&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;### 协议（Protocols）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;在书写协议的时候注意用`&amp;lt;&amp;gt;`括起来的协议和类型名之间是没有空格的，比如`IPCConnectHandler()&amp;lt;IPCPreconnectorDelegate&amp;gt;`,这个规则适用所有书写协议的地方，包括函数声明、类声明、实例变量等等：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	@interface MyProtocoledClass : NSObject&amp;lt;NSWindowDelegate&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	 @private&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	id&amp;lt;MyFancyDelegate&amp;gt; _delegate;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	- (void)setDelegate:(id&amp;lt;MyFancyDelegate&amp;gt;)aDelegate;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	@end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;### @public和@private标记符&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@public和@private标记符应该以**一个空格**来进行缩进：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	@interface MyClass : NSObject &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	 @public&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	  ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	 @private&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	  ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	@end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;### 枚举规范&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;### 单例模式&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;单例对象应该使用线程安全模式来创建共享实例。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;标准单例示例&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;static AppContext * dataEngineInstance=nil;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(AppContext*)sharedInstance{&lt;br&gt;  static dispatch_once_t onceToken;&lt;br&gt;  dispatch_once(&amp;amp;onceToken, ^{&lt;pre&gt;&lt;code&gt;dataEngineInstance=[[[self class] alloc] init];
&lt;/code&gt;&lt;/pre&gt;  });&lt;br&gt;  return dataEngineInstance;&lt;br&gt;}&lt;/li&gt;
&lt;li&gt;(instancetype)allocWithZone:(NSZone *)zone{&lt;br&gt;  if(dataEngineInstance==nil){&lt;pre&gt;&lt;code&gt;dataEngineInstance=[super allocWithZone:zone];
&lt;/code&gt;&lt;/pre&gt;  }&lt;br&gt;  return dataEngineInstance;&lt;br&gt;}&lt;br&gt;-(instancetype)copyWithZone:(NSZone *)zone{&lt;br&gt;  return dataEngineInstance;&lt;br&gt;}&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;(instancetype)init{&lt;br&gt;  @synchronized(dataEngineInstance) {&lt;pre&gt;&lt;code&gt;return dataEngineInstance;
&lt;/code&gt;&lt;/pre&gt;  }&lt;br&gt;  return dataEngineInstance;&lt;br&gt;}&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;### 预编译常量/宏&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;当我们想全局共用一些数据时，可以用宏、变量、常量&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;宏：&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;#define HSCoder @”汉斯哈哈哈”&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;变量：&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;NSString *HSCoder = @”汉斯哈哈哈”;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;常量：&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;四种写法：&lt;br&gt;static const NSString &lt;em&gt;HSCoder = @”汉斯哈哈哈”;&lt;br&gt;const NSString &lt;/em&gt;HSCoder = @”汉斯哈哈哈”;&lt;br&gt;NSString const &lt;em&gt;HSCoder = @”汉斯哈哈哈”;&lt;br&gt;NSString &lt;/em&gt; const HSCoder = @”汉斯哈哈哈”;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;思考：宏与常/变量的选择？&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* 宏：只是在预处理器里进行文本替换，没有类型，不做任何类型检查，编译器可以对相同的字符串进行优化。只保存一份到 .rodata 段。甚至有相同后缀的字符串也可以优化，你可以用GCC 编译测试，&amp;quot;Hello world&amp;quot; 与 &amp;quot;world&amp;quot; 两个字符串，只存储前面一个。取的时候只需要给前面和中间的地址，如果是整形、浮点型会有多份拷贝，但这些数写在指令中。占的只是代码段而已，大量用宏会导致二进制文件变大&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* 变量：共享一块内存空间，就算项目中N处用到，也不会分配N块内存空间，可以被修改，在编译阶段会执行类型检查&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* 常量：共享一块内存空间，就算项目中N处用到，也不会分配N块内存空间，可以根据const修饰的位置设定能否修改，在编译阶段会执行类型检查&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[iOS 宏(define)与常量(const)的正确使用](http://www.jianshu.com/p/f83335e036b5)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[iOS中的宏与常量](http://www.awnlab.com/archives/2608.html)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[宏定义的黑魔法](宏定义的黑魔法)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;## 注释/标注&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;### 标注&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#### TODO/FIXME/!!!/???&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;程序编码过程中，我们可以通过一些标注，来提示自己有些事情是需要以后来处理的，为了防止遗漏，加上TODO、FIXME、!!!、???和waring是很有必要的，我们可以通过下面的方式添加对应的提醒：&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;#!objective-c&lt;br&gt;    // TODO: 处理异常情况&lt;br&gt;    // FIXME: 此处需要清楚缓存&lt;br&gt;    // !!!: 此处逻辑不严谨，待完善&lt;br&gt;    // ???: 这块的实现上还存在难度，待研究跟进&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#warning 此处在特定情况下会出现异常，提交版本前一定要处理
&lt;/code&gt;&lt;/pre&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;前四种为备注说明，并且在预览方法时会清晰显示出来，后面warnning，是在编译程序后都会直接作为一个警告出现在编译结果中。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;在实际开发中，如果开发到中途，要需要处理的，务必加上对应的标志，防止再次来编辑时遗漏。另外，在提交版本前，一定要对这些标志进行一次检查，warnning能很明显的发现，其他四种可以采用插件Xcode插件[XToDo](https://github.com/trawor/XToDo)来查找。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#### pragma mark – &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;在显示文件中，需要对方法采用pragma mark – 来进行划分，保证方法类别清晰，避免造成方法过多时造成的混乱现象。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* 单行不超过100个字符，每个文件代码行数不超过1000行，每个函数代码不超过100行。对于过长的函数，尽量通过子函数或其他方式进行代码精简。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* 精简规则，在实现同样功能的情况下，需采用代码量最小的方式来编码；代码中尽量不要出现超过2次重复的地方。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;在函数分组和protocol/delegate实现中使用#pragma mark -来分类方法，要遵循以下一般结构：&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;#pragma mark - Lifecycle  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(instancetype)init {}  &lt;/li&gt;
&lt;li&gt;(void)dealloc {}  &lt;/li&gt;
&lt;li&gt;(void)viewDidLoad {}  &lt;/li&gt;
&lt;li&gt;(void)viewWillAppear:(BOOL)animated {}  &lt;/li&gt;
&lt;li&gt;(void)didReceiveMemoryWarning {}&lt;br&gt;#pragma mark - Custom Accessors  &lt;/li&gt;
&lt;li&gt;(void)setCustomProperty:(id)value {}  &lt;/li&gt;
&lt;li&gt;(id)customProperty {}&lt;br&gt;#pragma mark - IBActions  &lt;/li&gt;
&lt;li&gt;(IBAction)submitData:(id)sender {}&lt;br&gt;#pragma mark - Public  &lt;/li&gt;
&lt;li&gt;(void)publicMethod {}&lt;br&gt;#pragma mark - Private  &lt;/li&gt;
&lt;li&gt;(void)privateMethod {}&lt;br&gt;#pragma mark - Protocol conformance&lt;br&gt;#pragma mark - UITextFieldDelegate&lt;br&gt;#pragma mark - UITableViewDataSource&lt;br&gt;#pragma mark - UITableViewDelegate&lt;br&gt;#pragma mark - NSCopying  &lt;/li&gt;
&lt;li&gt;(id)copyWithZone:(NSZone *)zone {}&lt;br&gt;#pragma mark - NSObject  &lt;/li&gt;
&lt;li&gt;(NSString *)description {}&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;### 注释&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;为统一类、方法和属性的注释规则，注释工具推荐统一使用开源Xcode插件[VVDocumenter-Xcode](https://github.com/onevcat/VVDocumenter-Xcode)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;头文件的中的类名、属性、方法必须要进行注释；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* 头文件注释&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;header : 头文件基本信息。这个用在每个源代码文件的头文件的最开头。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;例如:&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;/&lt;em&gt;!&lt;br&gt;@header 这里的信息应该与该源代码文件的名字一致&lt;br&gt;@abstract 关于这个源代码文件的一些基本描述&lt;br&gt;@author Kevin Wu (作者信息)&lt;br&gt;@version 1.00 2012/01/20 Creation (此文档的版本信息)
&lt;/em&gt;/&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* 类注释&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class: 类信息。此注释用在类声明的开头。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;例如:&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;/&lt;em&gt;!&lt;br&gt;@class&lt;br&gt;@abstract 这里可以写关于这个类的一些描述。
&lt;/em&gt;/&lt;br&gt;@interface MyClass : NSObject {&lt;br&gt;}&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* 属性注释&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;property: property的相关注释。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;/&lt;em&gt;!&lt;br&gt;@property&lt;br&gt;@abstract 这里可以写关于这个Property的一些基本描述。
&lt;/em&gt;/&lt;br&gt;@property (nonatomic,readonly) NSString *helloDocText_;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;或者&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;/&lt;em&gt;* 这里可以写关于这个Property的一些基本描述。 &lt;/em&gt;/&lt;br&gt;@property (nonatomic,readonly) NSString *helloDocText_;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;建议使用第二种方式，这样在类中引用是可以看到当前属性注释信息&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* 函数(方法)注释&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;method: 函数(方法)的相关注释。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;例如:&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;/&lt;em&gt;!&lt;br&gt;@method&lt;br&gt;@abstract 这里可以写一些关于这个方法的一些简要描述&lt;br&gt;@discussion 这里可以具体写写这个方法如何使用，注意点之类的。如果你是设计一个抽象类或者一个&lt;br&gt;共通类给给其他类继承的话，建议在这里具体描述一下怎样使用这个方法。&lt;br&gt;@param text 文字 (这里把这个方法需要的参数列出来)&lt;br&gt;@param error 错误参照&lt;br&gt;@result 返回结果
&lt;/em&gt;/&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;(BOOL)showText:(NSString *)text&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;error:(NSError **)error; 
&lt;/code&gt;&lt;/pre&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* 枚举注释&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;enum: enum的相关注释。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;例如:&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;/&lt;em&gt;!&lt;br&gt;@enum&lt;br&gt;@abstract 关于这个enum的一些基本信息&lt;br&gt;@constant 枚举变量描述信息&lt;br&gt;@constant 枚举变量描述信息&lt;br&gt;…
&lt;/em&gt;/&lt;br&gt;typedef NS_ENUM(NSInteger, HelloDocEnumDocDemo){&lt;br&gt;    HelloDocEnumDocDemoTagNumberPopupView = 100,&lt;br&gt;    HelloDocEnumDocDemoTagNumberOKButton,&lt;br&gt;    …&lt;br&gt;};&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;* 协议注释&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;category: category的相关注释。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;例如:&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;/&lt;em&gt;!&lt;br&gt;@category&lt;br&gt;@abstract NSString的Category
&lt;/em&gt;/&lt;br&gt;@interface KevinNSString (NSString)&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;* 委托注释&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;protocol: protocol的相关注释&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;例如:&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;/&lt;em&gt;!&lt;br&gt;@protocol&lt;br&gt;@abstract 这个HelloDoc类的一个protocol&lt;br&gt;@discussion 具体描述信息可以写在这里
&lt;/em&gt;/&lt;br&gt;@protocol HelloDocDelegate ＜NSObject＞&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* 块注释&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;对于块注释，有多种多种风格&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;方法内部禁止使用块注释。除非要临时注释大段代码，一般情况总应使用行注释。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	* 风格一：&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code&gt;/////////////////////////////////////
// @name UIButton控件生成相关API
/////////////////////////////////////
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;* 风格二：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;``` &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 块功能说明&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;


* 风格三：

&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* 块功能说明&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*/&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;参考文档：&quot;&gt;&lt;a href=&quot;#参考文档：&quot; class=&quot;headerlink&quot; title=&quot;参考文档：&quot;&gt;&lt;/a&gt;参考文档：&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://www.zhwios.com/2015/09/17/--iOS%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83--/#A4.1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;iOS高级编程规范&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.zybuluo.com/FoxBabe/note/84957#大小写规则&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Objective-C 代码规范&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/QianKaiLu/Objective-C-Coding-Guidelines-In-Chinese&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Objective-C-Coding&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Chinamobo/iOS-Team-Norms/blob/master/CodeStyle.md&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Chinamobo Objective-C 编码规范&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/objc-zen/objc-zen-book&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;objc-zen-book(EN)&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;iOS开发规范（self）&quot;&gt;&lt;a href=&quot;#iOS开发规范（self）&quot; class=&quot;headerlink&quot; title=&quot;iOS开发规范（self）&quot;&gt;&lt;/a&gt;iOS开发规范（self）&lt;/h1&gt;&lt;p&gt;Objective-C是一门面向对象的动态编程语言，主要用于编写iOS和Mac应用程序。&lt;br&gt;
    
    </summary>
    
    
      <category term="Objective-C" scheme="http://yoursite.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>git使用-merage</title>
    <link href="http://yoursite.com/2016/03/29/git%E4%BD%BF%E7%94%A8-merage/"/>
    <id>http://yoursite.com/2016/03/29/git使用-merage/</id>
    <published>2016-03-29T10:28:13.000Z</published>
    <updated>2016-03-30T06:17:55.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Git使用—-merage&quot;&gt;&lt;a href=&quot;#Git使用—-merage&quot; class=&quot;headerlink&quot; title=&quot;Git使用—-merage&quot;&gt;&lt;/a&gt;Git使用—-merage&lt;/h2&gt;&lt;p&gt;在版本回退里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。&lt;/p&gt;
&lt;p&gt;一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点：&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;strong&gt;阅读全文&amp;gt;&amp;gt;&lt;/strong&gt;&lt;br&gt;&lt;br&gt;### git分支（branch）的操作命令&lt;br&gt;1.查看本地分支：   &lt;strong&gt;$ git branch&lt;/strong&gt; 或者 &lt;strong&gt;$ git branch -l&lt;/strong&gt;&lt;br&gt;&lt;br&gt;2.查看远程分支 ：  &lt;strong&gt;$ git branch -r&lt;/strong&gt;    或者 &lt;strong&gt;$ git brach -a&lt;/strong&gt;&lt;br&gt;&lt;br&gt;&lt;code&gt;-r是仅查询远程的分支， -a查询包含远程分支和本地分支&lt;/code&gt;&lt;br&gt;&lt;br&gt;3.创建本地分支：&lt;strong&gt;$ git branch name&lt;/strong&gt;&lt;br&gt;&lt;br&gt;&lt;code&gt;name为你想要创建的分支名 并且创建分之后不会自动切换到新的分支；&lt;/code&gt;&lt;br&gt;&lt;br&gt;4.切换分支 ： &lt;strong&gt;$ git checkout name&lt;/strong&gt;&lt;br&gt;&lt;br&gt;&lt;code&gt;可以先查询本地的分支，然后再checkout到你想要切换的分支；&lt;/code&gt;&lt;br&gt;&lt;br&gt;5.创建新分支并立即切换到新分支：&lt;strong&gt;$ git checkout -b name&lt;/strong&gt;&lt;br&gt;&lt;br&gt;&lt;code&gt;此命令可以直创建成功后切换到你所新创建的分支&lt;/code&gt;&lt;br&gt;&lt;br&gt;6.删除分支：&lt;strong&gt; $ git branch -d name &lt;/strong&gt;&lt;br&gt;&lt;br&gt;&lt;code&gt;-d选项只能删除已经参与了合并的分支，对于未有合并的分支是无法删除的。如果想强制删除一个分支，可以使用-D选项&lt;/code&gt;&lt;br&gt;&lt;br&gt;7.创建远程分支(本地分支push到远程)：&lt;strong&gt;$ git push origin [name]&lt;/strong&gt;&lt;br&gt;&lt;br&gt;&lt;code&gt;创建远程分支，并且同时把本地当前分支下的内容推送到所新建的远程分支&lt;/code&gt;&lt;br&gt;&lt;br&gt;8.删除远程分支：&lt;strong&gt;$ git push origin :heads/[name]&lt;/strong&gt; 或 $ &lt;strong&gt;git push origin :[name]&lt;/strong&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;如果想把本地的某个分支test提交到远程仓库，并作为远程仓库的master分支，或者作为另外一个名叫test的分支，如下：&lt;br&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$git push origin test:master         &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 提交本地test分支作为远程的master分支&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$git push origin test:test           &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 提交本地test分支作为远程的test分支&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;git分支合并（merge）的操作&quot;&gt;&lt;a href=&quot;#git分支合并（merge）的操作&quot; class=&quot;headerlink&quot; title=&quot;git分支合并（merge）的操作&quot;&gt;&lt;/a&gt;git分支合并（merge）的操作&lt;/h3&gt;&lt;p&gt; 在git中，可以使用 &lt;strong&gt;git merge&lt;/strong&gt; 和 &lt;strong&gt;git rebase&lt;/strong&gt; 两个命令来进行分支的合并。&lt;br&gt;&lt;strong&gt;git merge&lt;/strong&gt; 和 &lt;strong&gt;git rebase&lt;/strong&gt; 在大体上都差不多，下文主要以 &lt;strong&gt;git merge&lt;/strong&gt; 来例来讲解分支的合并流程。 &lt;/p&gt;
&lt;p&gt;git命令： &lt;strong&gt;$ git merge branchname &lt;/strong&gt;   &lt;/p&gt;
&lt;p&gt;—-这个命令把分支”branchname”合并到了当前分支里面。 &lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;&lt;em&gt;在执行这个命令前，需要先查看你当前所在的分支，是否是两个合并的分支中的一个，如果不是你想要合并的分支，先切换到两个分支中的一个，然后才可以进行合并的命令。如果在本地中未找到你想要的分支，你就需要把所有这个git库所有的分支先 pull 下来&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;下拉所有当前库中的所有分支 ： $ git pull – all&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; —- 在进行上面操作时需要先把分支切换到主分支&lt;/p&gt;
&lt;p&gt; 当你成功切换到其中一条分支后执行以下命令&lt;/p&gt;
 &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git merge otherBranchName &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;----otherBranchNmae 就是另外一条分支。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;解决合并中的冲突&quot;&gt;&lt;a href=&quot;#解决合并中的冲突&quot; class=&quot;headerlink&quot; title=&quot;解决合并中的冲突&quot;&gt;&lt;/a&gt;解决合并中的冲突&lt;/h3&gt;&lt;p&gt;如果执行自动合并没有成功的话，git会在索引和工作树里设置一个特殊的状态， 提示你如何解决合并中出现的冲突。&lt;br&gt;有冲突(conflicts)的文件会保存在&lt;strong&gt;索引&lt;/strong&gt;中，除非你解决了问题了并且更新了索引，否则执行 git commit都会失败:&lt;/p&gt;
&lt;p&gt;如果存在冲突，当你执行 $ git commit 命令后 执行 git status 会显示这些文件没有合并(unmerged),这些有冲突的文件里面会添加像下面的冲突标识符:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;fileName : needs merge&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; HEAD:file.txt&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Hello world&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;=======&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Goodbye&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; 77976da35a11db4580b80ae27e8d65caf5208086:file.txt&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;你所需要的做是就是编辑解决冲突，（接着把冲突标识符删掉），再执行下面的命令:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git add .&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git commit -m “”&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;撒销一个合并&quot;&gt;&lt;a href=&quot;#撒销一个合并&quot; class=&quot;headerlink&quot; title=&quot;撒销一个合并&quot;&gt;&lt;/a&gt;撒销一个合并&lt;/h3&gt;&lt;p&gt;如果你觉得你合并后的状态是一团乱麻，想把当前的修改都放弃，你可以用下面的命令回到合并之前的状态：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;$ git reset –hard HEAD&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;次命令不仅仅局限于撤销分支的合并。当你在在本地修改代码后，对于自己修改的不满意，并且不想自己手动改回去，可以执行上面的代码，代码会自动恢复到最后一次commit的版本。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;或者你已经把合并后的代码提交，但还是想把它们撒销：&lt;br&gt;&lt;strong&gt;$ git reset –hard ORIG_HEAD&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;但是刚才这条命令在某些情况会很危险，如果你把一个已经被另一个分支合并的分支给删了，那么 以后在合并相关的分支时会出错。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;关于撤销的更多内容请参考:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://hubingforever.blog.163.com/blog/static/1710405792012411094228/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《git reset简介》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;更多内容可以参看 &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/hudashi/article/details/7668798&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;git合并与冲突的解决&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://gitbook.liuhui998.com/3_3.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;分支与合并@基础&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://gitbook.liuhui998.com/5_3.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;高级分支与合并&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Git使用—-merage&quot;&gt;&lt;a href=&quot;#Git使用—-merage&quot; class=&quot;headerlink&quot; title=&quot;Git使用—-merage&quot;&gt;&lt;/a&gt;Git使用—-merage&lt;/h2&gt;&lt;p&gt;在版本回退里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。&lt;/p&gt;
&lt;p&gt;一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点：&lt;/p&gt;
    
    </summary>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>创建SSH</title>
    <link href="http://yoursite.com/2016/03/29/%E5%88%9B%E5%BB%BASSH/"/>
    <id>http://yoursite.com/2016/03/29/创建SSH/</id>
    <published>2016-03-29T10:27:46.000Z</published>
    <updated>2016-03-30T06:14:46.000Z</updated>
    
    <content type="html">&lt;p&gt;#How to Creation SSH&lt;br&gt;SSH是&lt;code&gt;Source Shell Protocol&lt;/code&gt;的缩写，SSh是为建立在&lt;code&gt;应用层&lt;/code&gt;和&lt;code&gt;传输层&lt;/code&gt;基础上的安全协议。SSH是目前较为可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用SSH可以有效防止远程管理过程中的信息泄漏问题。&lt;/p&gt;
&lt;p&gt;SSH最初是UNIX系统上的一个程序，后来逐渐扩展到其他操作平台。SSH在正确使用时可以弥补网络中的漏洞，SSH客户端适用于多种平台，几乎所有的UNIX平台，包括HP-UX、Linux、AIX、Solaris等等&lt;/p&gt;
&lt;p&gt;传统的网络服务程序，比如ftp、pop和telnet在本质上都是不安全的，因为他们在网络上是用明文进行口令的传输，有一些别有用心的人就可以非常容易的截取这些口令和数据。&lt;/p&gt;
&lt;p&gt;通过SSH，可以把所有传输的数据进行加密，而且SSH还有一个额外的好处就是传输的数据是经过加密处理的，所以可以加快传输的速度。SSH还有其他的很多功能，他既可以替代Telnet，又可以为FTP、PoP、甚至是PPP提供一个安全的通道。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;strong&gt;阅读全文&amp;gt;&amp;gt;&lt;/strong&gt;&lt;br&gt;&lt;br&gt;## SSH 功能&lt;br&gt;&lt;br&gt;SSH可以提供两种功能：&lt;br&gt;&lt;br&gt;1. SSH服务，提供远程登录&lt;br&gt;2. 类似于FTP的sftp-server，用于基于ssh的文件传输&lt;br&gt;&lt;br&gt;&lt;br&gt;## SSH工作机制：&lt;br&gt;&lt;br&gt;他们的工作机制大致是本地客户端发送一个连接请求到远程服务器，服务端检查申请的包和ip地址再发送密钥给ssh的客户端，本地再将密钥发送给服务端，自此建立连接。&lt;br&gt;&lt;br&gt;&lt;br&gt;## 连接方式&lt;br&gt;&lt;br&gt;###version 1&lt;br&gt;ssh主机（Server端）用RSA加密方式产生一个1024bit的RSA-key，用来产生公约与私钥的演算方法：&lt;br&gt;&lt;br&gt;1. 当ssh daemon（sshd）启动时，就会产生一个768-bit的公钥（或称为Server Key）存放在Server中&lt;br&gt;2. 当client端的联机请求发送后，Server将公钥发送给client，此时client会对比判断公钥的正确性，判断的依据/etc/ssh/ssh_knownhosts、$HOME/.ssh/known_hosts&lt;br&gt;3. client端接收768bit的Server Key之后，client自己也随机产生一个256bit的私钥（private key，或host key），并且以加密的方式传送给Server&lt;br&gt;4. Server与client在此联机过程中，就以一对1024bit的key pair来进行数据的传递&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;strong&gt;补充说明：&lt;/strong&gt;&lt;br&gt;&lt;br&gt;Public Key是放在Server上，而Client的软件需要能接收Public Key，计算出Private key，并把二者的组合成一把独一无二的key pair（因为Client每次的256bit的Private key是随机产生的），在Client端的用户默认目录下$HOME/.ssh/known_keys会记录曾经联机过的主机的Public Key，用以确认每次来自该主机的联机是否正确&lt;br&gt;###version 2&lt;br&gt;在version 1的联机过程中，当Server接收Client的Private key之后，就不会针对该联机的key pair进行校验，如过黑客传送了恶意代码，由于主机端部会检验联机的正确性，所以可能会接收该程序代码。&lt;br&gt;&lt;br&gt;在version 2中增加了一个确认联机正确性的diff-hellman机制在每次数据传输中Server都会以这种机制校验资料来源是否正确&lt;br&gt;&lt;br&gt;&lt;br&gt;## OperSSL软件：&lt;br&gt;OpenSSL是一种比较常见的SSH服务端和客户端软件。提供了sshd、shell、sftp功能，其默认端口是22，在Redhat、CentOS等Linux操作系统中的默认SSH Daemon就是这个了。&lt;br&gt;&lt;br&gt;### 下面对这个软件的几种用法加以说明：&lt;br&gt;&lt;strong&gt;A. Server keys记录：$HOME/.ssh/known_hosts&lt;/strong&gt;&lt;br&gt;&lt;br&gt;当Client端接收来自Server端的Public key之后，会主动的对比这个key的正确性，有下面的两种情况：&lt;br&gt;&lt;br&gt;1. 没有记录，那么会出现提示，是否接收来自Server的Public Key&lt;br&gt;2. 对比成功，直接提示输入密码&lt;br&gt;3. 如果出现了这样的登录提示：&lt;strong&gt; warning: Remote host identification has changed &lt;/strong&gt;那么说明上次登录的远程ssh主机的key已经被更改了，原因可能是Server的重启、重装或者更新了相关的软件，这时候的处理方式是将$HOME/.ssh/known_hosts文件中与主机相关的字段删除，重新接收来自Server的Public key&lt;br&gt;&lt;br&gt;&lt;strong&gt;B. 设置不用输入用户名和密码就能立即登录的目标主机&lt;/strong&gt;&lt;br&gt;&lt;br&gt;原理：将Client端产生的key复制到Server中&lt;br&gt;&lt;br&gt;在Client向Server登录时，由于两者在ssh要联机的信号传递中，就已经对比过key了，因此可以立即进入数据传输，而不需要输入密码。&lt;br&gt;&lt;br&gt;1. 在Client端建立Public key和Private key两个密钥，命令为ssh-keygen&lt;br&gt;2. 将Private-key放在client的默认目录下，$HOME/.ssh，并为该用户可读的状态&lt;br&gt;3. 把Public key放在任何一个你希望要用来登录主机的Server的某user的默认目录中的认证文件中&lt;br&gt;&lt;br&gt;##生成 Git SSH-key&lt;br&gt;当你第一次从git资料库中clone项目时，可能会需要配置SSH-key，因为项目本地端和远程端的项目管理是基于SSH的，下面让我们一起看看SSH-key的配置过程。&lt;br&gt;&lt;br&gt;###设置Git的username 和 email&lt;br&gt;在你生成SSH前，需要在本地进行用户名和email的验证&lt;br&gt;&lt;br&gt;&lt;strong&gt;代码如下：&lt;/strong&gt;&lt;br&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git config --global user.name &amp;quot;youruser.name&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git config --global user.email &amp;quot;youremailusername&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;###生成SSH密钥的过程：&lt;/p&gt;
&lt;p&gt;####首先查看你的本地是否已经有ssh密钥&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ cd ~/.ssh&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;如果没有密钥就不会有此文件，如有有悔备份删除&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;####生成密钥&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ ssh-keygen -t rsa -C &amp;quot;youremailusername&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;连续按3个回车键，密码为空。&lt;/p&gt;
&lt;p&gt;会得到以下消息:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Your identification has been saved in /home/tekkub/.ssh/id_rsa.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Your public key has been saved in /home/tekkub/.ssh/id_rsa.pub.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;The key fingerprint is:&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;最后会得到两个文件&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;id_ rsa&lt;/li&gt;
&lt;li&gt;id_rsa.pub&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;####查询SSH key&lt;/p&gt;
&lt;p&gt;你的SSH key存在于生成的&lt;code&gt;id_rsa.pub&lt;/code&gt;的文件中，&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ cat ~/.ssh/id_rsa.pub&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当执行上条命令的时候，如果已经生成key，则会出现类似&lt;br&gt;&lt;strong&gt; ssh-rsa  AAAAB3NzaC1yc2EAAAADAQABAAABAQC2Z/MOZdADABODQjvGDK+5j7IBefKFQPOen0aq1GpIzPFHclL62ddhrbjQUZ9IeDhxYwDU7Aq….wisher@wisher.local &lt;/strong&gt;&lt;br&gt;的字符串，这个就是本地生成的SSH key。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;#How to Creation SSH&lt;br&gt;SSH是&lt;code&gt;Source Shell Protocol&lt;/code&gt;的缩写，SSh是为建立在&lt;code&gt;应用层&lt;/code&gt;和&lt;code&gt;传输层&lt;/code&gt;基础上的安全协议。SSH是目前较为可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用SSH可以有效防止远程管理过程中的信息泄漏问题。&lt;/p&gt;
&lt;p&gt;SSH最初是UNIX系统上的一个程序，后来逐渐扩展到其他操作平台。SSH在正确使用时可以弥补网络中的漏洞，SSH客户端适用于多种平台，几乎所有的UNIX平台，包括HP-UX、Linux、AIX、Solaris等等&lt;/p&gt;
&lt;p&gt;传统的网络服务程序，比如ftp、pop和telnet在本质上都是不安全的，因为他们在网络上是用明文进行口令的传输，有一些别有用心的人就可以非常容易的截取这些口令和数据。&lt;/p&gt;
&lt;p&gt;通过SSH，可以把所有传输的数据进行加密，而且SSH还有一个额外的好处就是传输的数据是经过加密处理的，所以可以加快传输的速度。SSH还有其他的很多功能，他既可以替代Telnet，又可以为FTP、PoP、甚至是PPP提供一个安全的通道。&lt;/p&gt;
    
    </summary>
    
    
      <category term="基础技术" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>CocoaPods的安装过程</title>
    <link href="http://yoursite.com/2015/04/29/CocoaPods%E7%9A%84%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2015/04/29/CocoaPods的安装过程/</id>
    <published>2015-04-29T10:27:20.000Z</published>
    <updated>2016-04-17T16:41:52.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;CocoaPods&quot;&gt;&lt;a href=&quot;#CocoaPods&quot; class=&quot;headerlink&quot; title=&quot;CocoaPods&quot;&gt;&lt;/a&gt;CocoaPods&lt;/h1&gt;&lt;p&gt;CocoaPods 是开发 OS X 和 iOS 应用程序的一个第三方库的依赖管理工具。利用 CocoaPods，可以定义自己的依赖关系 (称作 pods)，并且随着时间的变化，以及在整个开发环境中对第三方库的版本管理非常方便。&lt;/p&gt;
&lt;p&gt;CocoaPods 背后的理念主要体现在两个方面。首先，在工程中引入第三方代码会涉及到许多内容。针对 Objective-C 初级开发者来说，工程文件的配置会让人很沮丧。在配置 build phases 和 linker flags 过程中，会引起许多人为因素的错误。CocoaPods 简化了这一切，它能够自动配置编译选项。&lt;/p&gt;
&lt;p&gt;其次，通过 CocoaPods，可以很方便的查找到新的第三方库。当然，这并不是说你可以简单的将别人提供的库拿来拼凑成一个应用程序。它的真正作用是让你能够找到真正好用的库，以此来缩短我们的开发周期和提升软件的质量。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;strong&gt;阅读全文&amp;gt;&amp;gt;&lt;/strong&gt;&lt;br&gt;&lt;br&gt;## Cocoapods下载第三方过程&lt;br&gt;### 下载cocoapod的索引&lt;br&gt;在想要用cocoapods 下载第三方类的时候，首先需要先下载cocoapod的索引&lt;br&gt;&lt;br&gt;    $sudo gem install cocoapods&lt;br&gt;&lt;br&gt;这时间会很长，需要等待…. 等到命令执行成功后，再进行以下操作&lt;br&gt;&lt;br&gt;&lt;br&gt;### 搜索第三方的名字&lt;br&gt;&lt;br&gt;当执行完上面的命令后，在进行搜索就会比较快，如果没有上述命令没有执行完毕，就执行搜索。那么会重新执行上述命令。&lt;br&gt;&lt;br&gt;搜索命令：&lt;br&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ pod search &amp;quot;三方类名称&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;会得到：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CocoaPods 0.36.0.beta.2 is available.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;To update use: `gem install cocoapods --pre`&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[!] This is a test version we&amp;apos;d love you to try.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;For more information see http://blog.cocoapods.org&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;and the CHANGELOG for this version http://git.io/BaH8pQ.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Setup completed&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-&amp;gt; AF2OAuth1Client (0.3.6)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   AFNetworking 2 Extension for OAuth 1.0a Authentication.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pod &amp;apos;AF2OAuth1Client&amp;apos;, &amp;apos;~&amp;gt; 0.3.6&amp;apos; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   - Homepage: https://github.com/AYastrebov/AF2OAuth1Client&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   - Source:   https://github.com/AYastrebov/AF2OAuth1Client.git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   - Versions: 0.3.6 [master repo]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-&amp;gt; AFAbstractRESTClient (1.0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   AFAbstractRESTClient is simple abstract solution to deal with REST&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   webservices using AFNetworking.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   pod &amp;apos;AFAbstractRESTClient&amp;apos;, &amp;apos;~&amp;gt; 1.0&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   - Homepage: https://github.com/burczyk/AFAbstractRESTClient&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   - Source:   https://github.com/burczyk/AFAbstractRESTClient.git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   - Versions: 1.0 [master repo]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-&amp;gt; AFAddressBookManager (1.1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   Get contacts from AddressBook by their phone numbers.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   pod &amp;apos;AFAddressBookManager&amp;apos;, &amp;apos;~&amp;gt; 1.1&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   - Homepage: https://github.com/Fogh/AFAddressBookManager&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   - Source:   https://github.com/Fogh/AFAddressBookManager.git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   - Versions: 1.1, 1.0.1, 1.0, 0.1.1, 0.1 [master repo]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;编辑-Podfile&quot;&gt;&lt;a href=&quot;#编辑-Podfile&quot; class=&quot;headerlink&quot; title=&quot;编辑 Podfile&quot;&gt;&lt;/a&gt;编辑 Podfile&lt;/h3&gt;&lt;p&gt;使用你喜欢的方式打开Podfile文件，&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$vim Podfile&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;先编辑Podfile中的模板&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Uncomment this line to define a global platform for your project&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;platform :ios, &amp;apos;6.0&amp;apos; ==&amp;gt; **6.0代表支持的最低版本**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;target &amp;apos;APPName&amp;apos; do&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;target &amp;apos;APPNameTests&amp;apos; do&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后把上述得出的命令中 &lt;code&gt;pod &amp;#39;AF2OAuth1Client&amp;#39;, &amp;#39;~&amp;gt; 0.3.6&amp;#39;&lt;/code&gt;编写进Podfile中&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Uncomment this line to define a global platform for your project&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;platform :ios, &amp;apos;6.0&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pod &amp;apos;AF2OAuth1Client&amp;apos;, &amp;apos;~&amp;gt; 0.3.6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;target &amp;apos;GuruJam&amp;apos; do&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;target &amp;apos;GuruJamTests&amp;apos; do&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;退出保存。&lt;/p&gt;
&lt;h3 id=&quot;下载或者更新-；&quot;&gt;&lt;a href=&quot;#下载或者更新-；&quot; class=&quot;headerlink&quot; title=&quot;下载或者更新 ；&quot;&gt;&lt;/a&gt;下载或者更新 ；&lt;/h3&gt;&lt;p&gt;如果你是第一次进行下载 那么执行&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ pod install&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果你这个项目不是第一次下载第三方那个，需要执行&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ pod update&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;更新并不是强制这样！！！ 可以执行 &lt;code&gt;pod install&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;在没有执行下载索引的时候下载或者更新第三方那个&quot;&gt;&lt;a href=&quot;#在没有执行下载索引的时候下载或者更新第三方那个&quot; class=&quot;headerlink&quot; title=&quot;在没有执行下载索引的时候下载或者更新第三方那个&quot;&gt;&lt;/a&gt;在没有执行下载索引的时候下载或者更新第三方那个&lt;/h3&gt;&lt;p&gt;如果你已经知道你想要下载的第三方的版本，可以直接添加到Podfile中&lt;/p&gt;
&lt;p&gt;然后执行:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ pod install --verbose --no-repo-update&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ pod update --verbose --no-repo-update&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样会为你节省很多的时间！！！！&lt;/p&gt;
&lt;h3 id=&quot;检查工程是否可以使用&quot;&gt;&lt;a href=&quot;#检查工程是否可以使用&quot; class=&quot;headerlink&quot; title=&quot;检查工程是否可以使用&quot;&gt;&lt;/a&gt;检查工程是否可以使用&lt;/h3&gt;&lt;p&gt;首先试着引入第三方的头文件。&lt;/p&gt;
&lt;p&gt;相信我 百分之八十是导不进来的 。。。&lt;/p&gt;
&lt;p&gt;那是以为你没有修改你的头文件路径，所以你就需要添加头文件路径。&lt;/p&gt;
&lt;p&gt;设置方法：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;找到： Target -&amp;gt; Build Settings -&amp;gt; Search Path -&amp;gt; User Header Search Path&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;添加： $&amp;#123;SRCROOT&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;修改：  后面的选项选为 recursive。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;然后试试吧。。  看看能不能导入头文件了 &lt;/p&gt;
&lt;p&gt;##删除项目中的cocopod文件&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;删除工程文件夹下的Podfile、Podfile.lock和Pods文件夹。&lt;/li&gt;
&lt;li&gt;删除xcworkspace 文件&lt;/li&gt;
&lt;li&gt;打开xcodeproj文件 删除项目中的libpods.a 和 Pods.xcconfig引用&lt;img src=&quot;http://img.blog.csdn.net/20140214225805921&quot; alt=&quot;Alt text&quot; title=&quot;Optional title&quot;&gt;&lt;/li&gt;
&lt;li&gt;打开Build Phases选项，删除Check Pods Manifest.lock和Copy Pods Resources：&lt;img src=&quot;http://img.blog.csdn.net/20140214230048593&quot; alt=&quot;Alt text&quot; title=&quot;Optional title&quot;&gt;&lt;/li&gt;
&lt;li&gt;完成，编译运行，无错通过。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ps:如果将cocoapods集成到工程中后不小心修改或删除了其相关文件导致无法便以通过例如：不小心把&lt;br&gt;Pods.xcconfig给删除了然后出现diff: /../Podfile.lock: No such file or directory，用上面的方法删除cocoapods后，&lt;br&gt;再重新$sudo pod install一下就好了。&lt;br&gt;如果编译的时候出现权限问题，对工程文件夹$sudo chmod 777 path-to-project-folder/&lt;em&gt;&lt;br&gt;$sudo chown 777 path-to-project-folder/&lt;/em&gt;&lt;br&gt;即可。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;CocoaPods&quot;&gt;&lt;a href=&quot;#CocoaPods&quot; class=&quot;headerlink&quot; title=&quot;CocoaPods&quot;&gt;&lt;/a&gt;CocoaPods&lt;/h1&gt;&lt;p&gt;CocoaPods 是开发 OS X 和 iOS 应用程序的一个第三方库的依赖管理工具。利用 CocoaPods，可以定义自己的依赖关系 (称作 pods)，并且随着时间的变化，以及在整个开发环境中对第三方库的版本管理非常方便。&lt;/p&gt;
&lt;p&gt;CocoaPods 背后的理念主要体现在两个方面。首先，在工程中引入第三方代码会涉及到许多内容。针对 Objective-C 初级开发者来说，工程文件的配置会让人很沮丧。在配置 build phases 和 linker flags 过程中，会引起许多人为因素的错误。CocoaPods 简化了这一切，它能够自动配置编译选项。&lt;/p&gt;
&lt;p&gt;其次，通过 CocoaPods，可以很方便的查找到新的第三方库。当然，这并不是说你可以简单的将别人提供的库拿来拼凑成一个应用程序。它的真正作用是让你能够找到真正好用的库，以此来缩短我们的开发周期和提升软件的质量。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Objective-C" scheme="http://yoursite.com/tags/Objective-C/"/>
    
  </entry>
  
</feed>
